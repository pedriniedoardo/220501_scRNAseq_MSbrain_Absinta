# AIM ---------------------------------------------------------------------
# test bulk deconvolution using BayesPrism

# libraries ---------------------------------------------------------------
library(Seurat)
library(BayesPrism)
library(tidyverse)

# read in the data --------------------------------------------------------
# read in the reference sc dataset
seurat_ref <- readRDS("/mnt/SSD01/training/routines/scRNAseq/R/Seurat/out/object/100_ifnb_DonorStim.rds")

# explore the metadata
seurat_ref@meta.data

# plot the dataset with the relative annotaiton
DimPlot(seurat_ref,group.by = "seurat_annotations")

# read in the sample pBulk generated. 
# this is just one sample generated by summing up all the cells form the reference dataset
# we need at least two samples
# bulk_counts <- readRDS("../out/object/rawCount_pBulk_treat_100_ifnb.rds")
bulk_counts <- readRDS("../out/object/rawCount_pBulk_all_100_ifnb.rds") %>%
  cbind(readRDS("../out/object/rawCount_pBulk_all_100_ifnb.rds"))

colnames(bulk_counts) <- c("V1","V2")

# produce the expected fraction per cell type for the bulk dataset
# LUT_prop <- seurat_ref@meta.data %>%
#   group_by(seurat_annotations,stim) %>%
#   summarise(n = n(),.groups = "drop") %>%
#   group_by(stim) %>%
#   mutate(tot = sum(n),
#          prop = n/tot)

LUT_prop <- seurat_ref@meta.data %>%
  group_by(seurat_annotations) %>%
  summarise(n = n(),.groups = "drop") %>%
  # group_by(stim) %>%
  mutate(tot = sum(n),
         prop = n/tot)


# Check the dimensions of our simulated data
dim(seurat_ref)
dim(bulk_counts)

#  Step 2: Prepare Data for BayesPrism ------------------------------------
# BayesPrism requires the data in specific formats. We need to extract the raw counts and cell labels from our Seurat object and ensure the gene names match between our reference and bulk data.

# Extract Information from the Seurat Object
# BayesPrism works best with raw counts.
sc_counts_matrix <- GetAssayData(seurat_ref, slot = "counts")

# Get cell type labels. These will be our 'cell.type.labels'.
cell_types <- seurat_ref$seurat_annotations

# Get cell state labels. For a simple case, these can be the same as cell types.
# In more complex analyses, these could be cluster IDs or subtypes.
# https://github.com/Danko-Lab/BayesPrism/issues/66
cell_states <- seurat_ref$seurat_annotations

# Filter and Align Genes
# reshape the data to be accepted by the tool
# generally data are reporeted as feature X sample, but in the tool they are handled as sample X feature.
# we can input sparse matrices: https://github.com/Danko-Lab/BayesPrism/issues/58
sc.dat <- t(sc_counts_matrix)
sc.dat[1:5,1:5]
dim(sc.dat)

bk.dat <- t(bulk_counts)
bk.dat[,1:5]
dim(bk.dat)

# Run the reccommended filtering on the genes in this step for a real data analysis
# Filter outlier genes from scRNA-seq data
# Next, we remove the genes from selected groups. Note that when sex is not identical between the reference and mixture, we recommend excluding genes from chrX and chrY. We also remove lowly transcribed genes, as the measurement of transcription of these genes tend to be noise-prone. Removal of these genes can also speed up computation.

sc.dat.filtered <- cleanup.genes(input = sc.dat,
                                 input.type = "count.matrix",
                                 species = "hs",
                                 gene.group = c( "Rb","Mrp","other_Rb","chrM","MALAT1","chrX","chrY") ,
                                 exp.cells = 5)

dim(sc.dat.filtered)
dim(sc.dat)

# Next, we check the concordance of gene expression for different types of genes. As bulk and single cell data are usually collected by different experimental protocols, they may have different sensitivity to different types of genes.
# note this function only works for human data. For other species, you are advised to make plots by yourself.
plot.bulk.vs.sc(sc.input = sc.dat.filtered,
                bulk.input = bk.dat
                #pdf.prefix="gbm.bk.vs.sc" specify pdf.prefix if need to output to pdf
)

# Subset protein coding genes.
sc.dat.filtered.pc <-  select.gene.type(sc.dat.filtered,
                                        gene.type = "protein_coding")
str(sc.dat.filtered.pc)
dim(sc.dat.filtered.pc)
dim(sc.dat.filtered)
dim(sc.dat)

# potentially run the DE to select markers gene per cell_type

# Step 3: Run BayesPrism Deconvolution ------------------------------------
# With the data properly formatted and aligned, we can now run the deconvolution.

# Construct the BayesPrism Object
# We combine the reference and cell labels into a 'prism' object.
my_prism <- new.prism(
  reference = sc.dat.filtered.pc,
  mixture = bk.dat,
  key = NULL, # No specific tumor/normal key needed for this example
  cell.type.labels = cell_types,
  cell.state.labels = cell_states,
  input.type = "count.matrix"
)

# Run the Deconvolution Algorithm
# This is the core computational step.
# We'll use 4 cores for this example. Adjust 'n.cores' as needed.
bp_results <- run.prism(prism = my_prism, n.cores = 20)

# You can look at the returned object to see what it contains
bp_results

# saveRDS(bp_results,"../out/object/bp_results_rawCount_pBulk_treat_100_ifnb.rds")
saveRDS(bp_results,"../out/object/bp_results_rawCount_pBulk_all_100_ifnb.rds")

# Step 4: Extract and Calculate Deconvoluted Reads ------------------------
# this can be extracted from the object as follows
# x <- "Endothelial"

list_bulk <- lapply(unique(cell_types), function(x){
  mat <- get.exp(bp=bp_results,
                 state.or.type="type",
                 cell.name=x)
  
  data <- mat %>%
    t()
  
  return(data)
}) %>%
  setNames(unique(cell_types))

# generate integer estimates
list_bulk_integer <- lapply(unique(cell_types), function(x){
  mat <- get.exp(bp=bp_results,
                 state.or.type="type",
                 cell.name=x)
  
  # generate integer level estimates
  # https://github.com/Danko-Lab/BayesPrism/issues/121
  # round up the Z matrix to the nearest integer and use it as input for DESeq2 (without any normalization step).
  data <- mat %>%
    t() %>%
    round()
  return(data)
}) %>%
  setNames(unique(cell_types))

# notice that the number of genes matches the one present in the reference
lapply(list_bulk, function(x){
  dim(x)
})

dim(sc.dat.filtered.pc)

# get the fraction estimated
theta <- get.fraction(bp=bp_results,
                      which.theta="final",
                      state.or.type="type")
theta

# test --------------------------------------------------------------------
# compare the expected prop vs the actual ones

# df_cor <- full_join(
#   LUT_prop,
#   theta %>%
#     as.data.frame() %>%
#     rownames_to_column("sample_id") %>%
#     pivot_longer(names_to = "cell_type",values_to = "prop",-sample_id),
#   by = c("stim" = "sample_id","seurat_annotations"="cell_type"),suffix = c(".expexted",".BayesPrism"))

df_cor <- full_join(
  LUT_prop,
  theta %>%
    as.data.frame() %>%
    rownames_to_column("sample_id") %>%
    pivot_longer(names_to = "cell_type",values_to = "prop",-sample_id),
  by = c("seurat_annotations"="cell_type"),suffix = c(".expexted",".BayesPrism"))

df_cor %>%
  ggplot(aes(x=prop.expexted,y=prop.BayesPrism)) +
  geom_point() +
  geom_abline(intercept = 0,slope = 1,col="red",linetype = "dashed") +
  theme_bw() +
  # facet_wrap(~seurat_annotations)+
  theme(strip.background = element_blank())

# confirm that the sum of the deconvoluted pBulk per sample correponds to the actual ionput values
bulk_convoluted <- purrr::reduce(list_bulk,`+`)

# the two matrices are not the same as the convoluted version is missing the genes that have been filtered out
dim(bulk_counts)
dim(bulk_convoluted)

# match the gene id in both objects before making the comparison
gene_id <- rownames(bulk_convoluted)
str(bulk_convoluted)
str(bulk_counts[gene_id,] %>% as.matrix())

# they are the same
all.equal(bulk_convoluted,bulk_counts[gene_id,] %>% as.matrix())